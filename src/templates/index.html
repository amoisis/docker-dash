<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>docker-dash - Cache Viewer</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <style>
        body {
            padding: 1rem;
        }
        h2 {
            margin-top: 2.5rem;
        }
        h3 {
            margin-top: 2rem;
        }
        table {
            overflow-x: auto;
        }
        pre {
            font-size: 0.8rem;
            background-color: var(--card-background-color);
            border: 1px solid var(--card-border-color);
        }
    </style>
</head>
<body>
    <main class="container">
        <nav>
            <h1>docker-dash</h1>
            <ul>
                <li><small id="last-updated" style="margin-right: 1rem;">Loading...</small></li>
                <li><button id="refresh-button" class="secondary">üîÑ Refresh</button></li>
                <li><a href="#" role="button" id="theme-toggle"></a></li>
            </ul>
        </nav>
        <div id="cache-container">
            <p aria-busy="true">Loading cache data...</p>
        </div>
    </main>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            const html = document.documentElement;
            const themeToggle = document.getElementById('theme-toggle');
            const refreshButton = document.getElementById('refresh-button');
            const lastUpdatedEl = document.getElementById('last-updated');
            const cacheContainer = document.getElementById('cache-container');
            
            // Auto-refresh interval in milliseconds (30 seconds)
            const AUTO_REFRESH_INTERVAL = 30000;
            let refreshInterval = null;

            // Sanitizer function to prevent XSS
            function sanitize(text) {
                const element = document.createElement('div');
                element.innerText = text;
                return element.innerHTML;
            }

            // Recursively sanitize data
            function sanitizeData(data) {
                if (data === null || data === undefined) {
                    return data;
                }
                if (Array.isArray(data)) {
                    return data.map(sanitizeData);
                }
                if (typeof data === 'object') {
                    const sanitizedObject = {};
                    for (const key in data) {
                        if (Object.prototype.hasOwnProperty.call(data, key)) {
                            sanitizedObject[key] = sanitizeData(data[key]);
                        }
                    }
                    return sanitizedObject;
                }
                if (typeof data === 'string') {
                    // Allow certain HTML tags for display purposes, but sanitize the content
                    const allowedTags = /^(<i>|<\/i>|‚úÖ|‚ùå)$/;
                    if (allowedTags.test(data)) {
                        return data;
                    }
                    return sanitize(data);
                }
                return data;
            }

            function updateButtonText() {
                const currentTheme = html.getAttribute('data-theme');
                themeToggle.textContent = currentTheme === 'dark' ? 'Light Mode' : 'Dark Mode';
            }

            // 1. On load, apply saved theme and update button text
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                html.setAttribute('data-theme', savedTheme);
            }
            updateButtonText();

            // 2. Add click listener for the toggle button
            themeToggle.addEventListener('click', (event) => {
                event.preventDefault();
                const currentTheme = html.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                html.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                updateButtonText();
            });

            // Helper to create a table from an array of objects
            function createTable(title, headers, dataRows) {
                let html = `<h2>${sanitize(title)}</h2>`;
                if (dataRows.length === 0) {
                    html += '<p>No data found in cache.</p>';
                    return html;
                }
                html += '<table><thead><tr>';
                headers.forEach(h => html += `<th>${sanitize(h)}</th>`);
                html += '</tr></thead><tbody>';
                dataRows.forEach(row => {
                    html += '<tr>';
                    row.forEach(cell => html += `<td>${cell}</td>`); // Cells are pre-sanitized
                    html += '</tr>';
                });
                html += '</tbody></table>';
                return html;
            }

            // Function to update the last updated timestamp
            function updateTimestamp() {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                lastUpdatedEl.textContent = `Last updated: ${timeString}`;
            }

            // Function to fetch and render cache data
            function fetchAndRenderCache() {
                // Show loading state on refresh button
                refreshButton.setAttribute('aria-busy', 'true');
                refreshButton.disabled = true;
                
                fetch('/api/cache')
                    .then(response => response.json())
                    .then(initialData => {
                        const data = sanitizeData(initialData); // Sanitize all incoming data
                        cacheContainer.innerHTML = ''; // Clear previous content

                        // 1. Tunnels Summary Table
                        const tunnels = Object.values(data.tunnels || {}).map(t => t.tunnel_object);
                        const tunnelRows = tunnels.map(t => [t.name, t.status, t.tun_type]);
                        cacheContainer.innerHTML += createTable('Tunnels', ['Name', 'Status', 'Type'], tunnelRows);

                        // 2. Application Policies Table
                        const policies = Object.values(data.access_policies || {});
                        const policyRows = policies.map(p => [p.name, p.decision, p.app_count || 0]);
                        cacheContainer.innerHTML += createTable('Application Policies', ['Name', 'Decision', 'App Count'], policyRows);

                        // 3. Identity Providers Table
                        const idps = Object.values(data.identity_providers || {});
                        const idpRows = idps.map(idp => [
                            idp.name,
                            idp.config?.client_id || 'N/A',
                            idp.config?.redirect_url || 'N/A'
                        ]);
                        cacheContainer.innerHTML += createTable('Identity Providers', ['Name', 'Client ID', 'Redirect URL'], idpRows);

                        // 4. Access Applications Table
                        const apps = Object.values(data.access_applications || {});
                        const policyCache = data.access_policies || {};
                        const appRows = apps.map(app => {
                            const appPolicies = (app.policies || [])
                                .map(p => {
                                    const foundPolicy = Object.values(policyCache).find(cachedPolicy => cachedPolicy.id === p.id);
                                    return foundPolicy ? foundPolicy.name : p.id;
                                })
                                .join(', ');
                            return [
                                app.domain,
                                app.type,
                                appPolicies || '<i>None</i>',
                                app.auto_redirect_to_identity ? '‚úÖ True' : '‚ùå False'
                            ];
                        });
                        cacheContainer.innerHTML += createTable('Access Applications', ['Domain', 'Type', 'Policies', 'Instant Auth'], appRows);

                        // 5. Tunnel - Current Hostnames Table
                        const tunnelsData = data.tunnels || {};
                        let connectionsHtml = `<h2>Tunnel - Current Hostnames</h2>`;
                        if (Object.keys(tunnelsData).length > 0) {
                            for (const tunnelId in tunnelsData) {
                                const tunnelInfo = tunnelsData[tunnelId];
                                const tunnelName = tunnelInfo.tunnel_object.name;
                                const connections = tunnelInfo.connections || [];

                                connectionsHtml += `<h3>${sanitize(tunnelName)}</h3>`;
                                connectionsHtml += `
                                    <table>
                                        <thead>
                                            <tr><th>Hostname</th><th>Service</th></tr>
                                        </thead>
                                        <tbody>
                                            ${connections.length > 0 ? connections.map(conn => `
                                                <tr>
                                                    <td>${conn.hostname || '<i>(Catch-all)</i>'}</td>
                                                    <td>${conn.service}</td>
                                                </tr>
                                            `).join('') : '<tr><td colspan="2">No connections configured for this tunnel.</td></tr>'}
                                        </tbody>
                                    </table>
                                `;
                            }
                        } else {
                            connectionsHtml += '<p>No tunnels found in cache.</p>';
                        }
                        cacheContainer.innerHTML += connectionsHtml;
                        
                        // Update timestamp
                        updateTimestamp();
                    })
                    .catch(error => {
                        const sanitizedError = sanitize(error.toString());
                        cacheContainer.innerHTML = '<p role="alert">Error loading cache data: ' + sanitizedError + '</p>';
                        lastUpdatedEl.textContent = 'Update failed';
                    })
                    .finally(() => {
                        // Remove loading state from refresh button
                        refreshButton.setAttribute('aria-busy', 'false');
                        refreshButton.disabled = false;
                    });
            }

            // 3. Manual refresh button
            refreshButton.addEventListener('click', (event) => {
                event.preventDefault();
                fetchAndRenderCache();
            });

            // 4. Start auto-refresh
            function startAutoRefresh() {
                // Clear any existing interval
                if (refreshInterval) {
                    clearInterval(refreshInterval);
                }
                // Set up new interval
                refreshInterval = setInterval(fetchAndRenderCache, AUTO_REFRESH_INTERVAL);
            }

            // 5. Initial fetch and start auto-refresh
            fetchAndRenderCache();
            startAutoRefresh();
            
            // 6. Stop auto-refresh when tab is not visible to save resources
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    if (refreshInterval) {
                        clearInterval(refreshInterval);
                        refreshInterval = null;
                    }
                } else {
                    // Resume auto-refresh and do an immediate refresh when tab becomes visible
                    fetchAndRenderCache();
                    startAutoRefresh();
                }
            });
        });
    </script>
</body>
</html>